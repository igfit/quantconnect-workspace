"""
Strategy Specification Data Structures

Defines the schema for strategy definitions that can be:
- Generated by AI
- Compiled to QuantConnect Python code
- Serialized to/from JSON for version control
"""

from dataclasses import dataclass, field, asdict
from typing import List, Optional, Union, Dict, Any, Literal
from enum import Enum
import json
import uuid
from datetime import datetime


class Timeframe(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"


class UniverseType(str, Enum):
    STATIC = "static"
    DYNAMIC = "dynamic"


class Operator(str, Enum):
    GREATER_THAN = ">"
    LESS_THAN = "<"
    GREATER_EQUAL = ">="
    LESS_EQUAL = "<="
    EQUALS = "=="
    CROSSES_ABOVE = "crosses_above"
    CROSSES_BELOW = "crosses_below"


class Logic(str, Enum):
    AND = "AND"
    OR = "OR"


@dataclass
class UniverseFilters:
    """Filters for dynamic universe selection"""
    min_price: float = 5.0
    min_dollar_volume: float = 500_000
    sector: Optional[str] = None
    index: Optional[str] = None  # "SP500", "NASDAQ100"
    max_symbols: int = 50

    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in asdict(self).items() if v is not None}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "UniverseFilters":
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})


@dataclass
class UniverseSpec:
    """Specification for stock universe selection"""
    type: UniverseType
    symbols: List[str] = field(default_factory=list)  # For static type
    filters: Optional[UniverseFilters] = None  # For dynamic type

    def to_dict(self) -> Dict[str, Any]:
        result = {"type": self.type.value if isinstance(self.type, UniverseType) else self.type}
        if self.symbols:
            result["symbols"] = self.symbols
        if self.filters:
            result["filters"] = self.filters.to_dict()
        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "UniverseSpec":
        universe_type = data.get("type", "static")
        if isinstance(universe_type, str):
            universe_type = UniverseType(universe_type)

        filters = None
        if "filters" in data and data["filters"]:
            filters = UniverseFilters.from_dict(data["filters"])

        return cls(
            type=universe_type,
            symbols=data.get("symbols", []),
            filters=filters
        )


@dataclass
class IndicatorSpec:
    """Specification for a technical indicator"""
    name: str  # Reference name (e.g., "fast_sma")
    type: str  # Indicator type (e.g., "SMA", "RSI")
    params: Dict[str, Any] = field(default_factory=dict)
    source: str = "close"  # Price field: close, open, high, low, volume

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "IndicatorSpec":
        return cls(**data)

    def get_period(self) -> int:
        """Get the primary period parameter for warmup calculation"""
        if "period" in self.params:
            return self.params["period"]
        if "slow_period" in self.params:
            return self.params["slow_period"]
        return 20  # Default


@dataclass
class Condition:
    """A single condition for entry/exit logic"""
    left: str  # Indicator name, "price", or "price.close", etc.
    operator: Operator
    right: Union[str, float]  # Another indicator name or a threshold value

    def to_dict(self) -> Dict[str, Any]:
        return {
            "left": self.left,
            "operator": self.operator.value if isinstance(self.operator, Operator) else self.operator,
            "right": self.right
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Condition":
        operator = data["operator"]
        if isinstance(operator, str):
            operator = Operator(operator)
        return cls(
            left=data["left"],
            operator=operator,
            right=data["right"]
        )


@dataclass
class ConditionGroup:
    """A group of conditions with AND/OR logic"""
    logic: Logic
    conditions: List[Condition] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "logic": self.logic.value if isinstance(self.logic, Logic) else self.logic,
            "conditions": [c.to_dict() for c in self.conditions]
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ConditionGroup":
        logic = data.get("logic", "AND")
        if isinstance(logic, str):
            logic = Logic(logic)
        conditions = [Condition.from_dict(c) for c in data.get("conditions", [])]
        return cls(logic=logic, conditions=conditions)


@dataclass
class RiskSpec:
    """Risk management specification"""
    position_size_dollars: float = 10_000
    stop_loss_pct: Optional[float] = None  # e.g., 0.05 = 5%
    take_profit_pct: Optional[float] = None
    max_holding_days: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in asdict(self).items() if v is not None}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RiskSpec":
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})


@dataclass
class ParameterRange:
    """Range specification for parameter sweeping"""
    path: str  # Dot-notation path, e.g., "indicators.0.params.period"
    values: List[Any]  # Concrete values to sweep

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ParameterRange":
        return cls(**data)


@dataclass
class StrategySpec:
    """
    Complete strategy specification.

    Can be:
    - Generated by AI
    - Compiled to QuantConnect Python code
    - Serialized to JSON for version control
    """
    # Metadata
    id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    name: str = ""
    description: str = ""
    rationale: str = ""  # Why this strategy might work
    parent_id: Optional[str] = None  # If derived from another strategy
    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())

    # Universe
    universe: UniverseSpec = field(default_factory=lambda: UniverseSpec(type=UniverseType.STATIC))

    # Timeframe
    timeframe: Timeframe = Timeframe.DAILY

    # Indicators (max 3 for KISS)
    indicators: List[IndicatorSpec] = field(default_factory=list)

    # Entry conditions (max 2)
    entry_conditions: ConditionGroup = field(
        default_factory=lambda: ConditionGroup(logic=Logic.AND)
    )

    # Exit conditions (max 2)
    exit_conditions: ConditionGroup = field(
        default_factory=lambda: ConditionGroup(logic=Logic.AND)
    )

    # Risk management
    risk_management: RiskSpec = field(default_factory=RiskSpec)

    # Parameter ranges for sweeping
    parameters: List[ParameterRange] = field(default_factory=list)

    def validate(self) -> List[str]:
        """Validate the strategy spec against KISS constraints"""
        errors = []

        if len(self.indicators) > 3:
            errors.append(f"Too many indicators: {len(self.indicators)} (max 3)")

        if len(self.entry_conditions.conditions) > 2:
            errors.append(f"Too many entry conditions: {len(self.entry_conditions.conditions)} (max 2)")

        if len(self.exit_conditions.conditions) > 2:
            errors.append(f"Too many exit conditions: {len(self.exit_conditions.conditions)} (max 2)")

        if not self.name:
            errors.append("Strategy must have a name")

        if self.universe.type == UniverseType.STATIC and not self.universe.symbols:
            errors.append("Static universe must have at least one symbol")

        if not self.entry_conditions.conditions:
            errors.append("Strategy must have at least one entry condition")

        if not self.exit_conditions.conditions:
            errors.append("Strategy must have at least one exit condition")

        # Validate indicator references in conditions
        indicator_names = {ind.name for ind in self.indicators}
        valid_refs = indicator_names | {"price", "price.close", "price.open", "price.high", "price.low", "volume"}

        for cond in self.entry_conditions.conditions + self.exit_conditions.conditions:
            if cond.left not in valid_refs:
                errors.append(f"Invalid condition reference: {cond.left}")
            if isinstance(cond.right, str) and cond.right not in valid_refs:
                errors.append(f"Invalid condition reference: {cond.right}")

        return errors

    def get_max_indicator_period(self) -> int:
        """Get the maximum indicator period for warmup calculation"""
        if not self.indicators:
            return 20
        return max(ind.get_period() for ind in self.indicators)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "rationale": self.rationale,
            "parent_id": self.parent_id,
            "created_at": self.created_at,
            "universe": self.universe.to_dict(),
            "timeframe": self.timeframe.value if isinstance(self.timeframe, Timeframe) else self.timeframe,
            "indicators": [ind.to_dict() for ind in self.indicators],
            "entry_conditions": self.entry_conditions.to_dict(),
            "exit_conditions": self.exit_conditions.to_dict(),
            "risk_management": self.risk_management.to_dict(),
            "parameters": [p.to_dict() for p in self.parameters],
        }

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string"""
        return json.dumps(self.to_dict(), indent=indent)

    def save(self, filepath: str) -> None:
        """Save to JSON file"""
        with open(filepath, 'w') as f:
            f.write(self.to_json())

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "StrategySpec":
        """Create from dictionary"""
        timeframe = data.get("timeframe", "daily")
        if isinstance(timeframe, str):
            timeframe = Timeframe(timeframe)

        return cls(
            id=data.get("id", str(uuid.uuid4())[:8]),
            name=data.get("name", ""),
            description=data.get("description", ""),
            rationale=data.get("rationale", ""),
            parent_id=data.get("parent_id"),
            created_at=data.get("created_at", datetime.utcnow().isoformat()),
            universe=UniverseSpec.from_dict(data.get("universe", {"type": "static"})),
            timeframe=timeframe,
            indicators=[IndicatorSpec.from_dict(i) for i in data.get("indicators", [])],
            entry_conditions=ConditionGroup.from_dict(data.get("entry_conditions", {"logic": "AND", "conditions": []})),
            exit_conditions=ConditionGroup.from_dict(data.get("exit_conditions", {"logic": "AND", "conditions": []})),
            risk_management=RiskSpec.from_dict(data.get("risk_management", {})),
            parameters=[ParameterRange.from_dict(p) for p in data.get("parameters", [])],
        )

    @classmethod
    def from_json(cls, json_str: str) -> "StrategySpec":
        """Create from JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def load(cls, filepath: str) -> "StrategySpec":
        """Load from JSON file"""
        with open(filepath, 'r') as f:
            return cls.from_json(f.read())


# =============================================================================
# EXAMPLE STRATEGY SPECS
# =============================================================================

def create_example_momentum_strategy() -> StrategySpec:
    """Create an example momentum strategy for testing"""
    return StrategySpec(
        name="Simple Momentum",
        description="Buy when price crosses above 50-day SMA with RSI confirmation",
        rationale="Follow established uptrends with momentum confirmation. "
                  "Works because trends tend to persist in the short term.",
        universe=UniverseSpec(
            type=UniverseType.STATIC,
            symbols=["AAPL", "MSFT", "GOOGL", "AMZN", "NVDA"]
        ),
        timeframe=Timeframe.DAILY,
        indicators=[
            IndicatorSpec(name="sma_50", type="SMA", params={"period": 50}),
            IndicatorSpec(name="rsi_14", type="RSI", params={"period": 14}),
        ],
        entry_conditions=ConditionGroup(
            logic=Logic.AND,
            conditions=[
                Condition(left="price", operator=Operator.CROSSES_ABOVE, right="sma_50"),
                Condition(left="rsi_14", operator=Operator.GREATER_THAN, right=50),
            ]
        ),
        exit_conditions=ConditionGroup(
            logic=Logic.OR,
            conditions=[
                Condition(left="price", operator=Operator.CROSSES_BELOW, right="sma_50"),
                Condition(left="rsi_14", operator=Operator.LESS_THAN, right=30),
            ]
        ),
        risk_management=RiskSpec(
            position_size_dollars=10_000,
            stop_loss_pct=0.07,
        ),
        parameters=[
            ParameterRange(path="indicators.0.params.period", values=[20, 50, 100, 200]),
            ParameterRange(path="indicators.1.params.period", values=[7, 14, 21]),
        ]
    )


def create_example_mean_reversion_strategy() -> StrategySpec:
    """Create an example mean reversion strategy for testing"""
    return StrategySpec(
        name="RSI Mean Reversion",
        description="Buy oversold conditions in uptrending stocks",
        rationale="Stocks that are oversold in an uptrend tend to bounce. "
                  "The 200-day SMA filter ensures we only buy quality pullbacks.",
        universe=UniverseSpec(
            type=UniverseType.STATIC,
            symbols=["TSLA", "NVDA", "AMD", "SQ", "COIN"]
        ),
        timeframe=Timeframe.DAILY,
        indicators=[
            IndicatorSpec(name="rsi_7", type="RSI", params={"period": 7}),
            IndicatorSpec(name="sma_200", type="SMA", params={"period": 200}),
        ],
        entry_conditions=ConditionGroup(
            logic=Logic.AND,
            conditions=[
                Condition(left="rsi_7", operator=Operator.LESS_THAN, right=25),
                Condition(left="price", operator=Operator.GREATER_THAN, right="sma_200"),
            ]
        ),
        exit_conditions=ConditionGroup(
            logic=Logic.OR,
            conditions=[
                Condition(left="rsi_7", operator=Operator.GREATER_THAN, right=70),
            ]
        ),
        risk_management=RiskSpec(
            position_size_dollars=10_000,
            max_holding_days=5,
        ),
        parameters=[
            ParameterRange(path="indicators.0.params.period", values=[5, 7, 10, 14]),
            ParameterRange(path="entry_conditions.conditions.0.right", values=[20, 25, 30]),
        ]
    )
