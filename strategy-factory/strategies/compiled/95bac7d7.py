
from AlgorithmImports import *
from datetime import timedelta


class TrendFilter(QCAlgorithm):
    """
    Trend Filter

    Buy when price crosses above SMA, sell when crosses below

    Rationale: Simple trend following using price/SMA crossover. Captures trend changes and rides momentum. Works well on volatile growth stocks.

    Generated by Strategy Factory
    Strategy ID: 95bac7d7
    """

    def initialize(self):
        # =================================================================
        # BACKTEST CONFIGURATION
        # =================================================================
        self.set_start_date(2020, 1, 1)
        self.set_end_date(2024, 12, 31)
        self.set_cash(100000)

        # =================================================================
        # EXECUTION MODEL - SAFETY GUARDS
        # =================================================================
        # Combined security initializer: slippage + commission
        def initialize_security(security):
            # Slippage: 0.1% per trade
            security.set_slippage_model(ConstantSlippageModel(0.001))
            # Commission: IBKR model ($0.005/share, $1 min)
            security.set_fee_model(InteractiveBrokersFeeModel())

        self.set_security_initializer(initialize_security)

        # =================================================================
        # UNIVERSE SETUP
        # =================================================================
        self.symbols = []
        # Static universe
        for ticker in ["TSLA", "NVDA", "AMD", "SQ", "SHOP", "COIN"]:
            equity = self.add_equity(ticker, Resolution.DAILY)
            self.symbols.append(equity.symbol)

        # Set benchmark
        if self.symbols:
            self.set_benchmark(self.symbols[0])

        # =================================================================
        # INDICATORS
        # =================================================================
        self.indicators = {}
        self.prev_indicator_values = {}  # For crossover detection
        # Indicator: sma_50 (SMA)
        for symbol in self.symbols:
            if symbol not in self.indicators:
                self.indicators[symbol] = {}
            self.indicators[symbol]['sma_50'] = self.sma(symbol, 50, Resolution.DAILY)
        

        # =================================================================
        # POSITION TRACKING
        # =================================================================
        self.position_size_dollars = 10000
        self.entry_prices = {}
        self.entry_dates = {}
        self.pending_entries = set()  # Signals generated, waiting for next open
        self.pending_exits = set()    # Exit signals, waiting for next open

        # =================================================================
        # RISK MANAGEMENT
        # =================================================================
        self.stop_loss_pct = 0.1
        self.take_profit_pct = None
        self.max_holding_days = None

        # =================================================================
        # WARMUP
        # =================================================================
        warmup_period = 60
        self.set_warmup(timedelta(days=warmup_period))

        # =================================================================
        # SCHEDULED EVENTS
        # =================================================================
        # Process signals at market open (execute pending orders)
        self.schedule.on(
            self.date_rules.every_day(),
            self.time_rules.after_market_open(self.symbols[0] if self.symbols else "SPY", 1),
            self.execute_pending_orders
        )

        # Generate signals at market close (for next day execution)
        self.schedule.on(
            self.date_rules.every_day(),
            self.time_rules.before_market_close(self.symbols[0] if self.symbols else "SPY", 5),
            self.generate_signals
        )

    def execute_pending_orders(self):
        """
        Execute pending orders at market open.

        SAFETY: This ensures we trade on the NEXT day's open,
        not on the close where we generated the signal.
        """
        if self.is_warming_up:
            return

        # Execute pending exits first
        for symbol in list(self.pending_exits):
            if self.portfolio[symbol].invested:
                self.liquidate(symbol, "Exit signal")
                self.log(f"EXIT: {symbol} at open")
                if symbol in self.entry_prices:
                    del self.entry_prices[symbol]
                if symbol in self.entry_dates:
                    del self.entry_dates[symbol]
            self.pending_exits.discard(symbol)

        # Execute pending entries
        for symbol in list(self.pending_entries):
            if not self.portfolio[symbol].invested:
                # Check liquidity and price filters
                if not self._passes_filters(symbol):
                    self.pending_entries.discard(symbol)
                    continue

                # Calculate position size
                price = self.securities[symbol].price
                if price <= 0:
                    self.pending_entries.discard(symbol)
                    continue

                shares = int(self.position_size_dollars / price)
                if shares > 0:
                    self.market_order(symbol, shares)
                    self.entry_prices[symbol] = price
                    self.entry_dates[symbol] = self.time
                    self.log(f"ENTRY: {symbol} {shares} shares at ~${price:.2f}")

            self.pending_entries.discard(symbol)

    def generate_signals(self):
        """
        Generate entry/exit signals at market close.

        SAFETY: Signals are queued for next-day execution,
        preventing look-ahead bias.
        """
        if self.is_warming_up:
            return

        # Initialize prev values on first run (needed for crossover detection)
        if not self.prev_indicator_values:
            self._update_prev_values()
            return  # Skip first day to establish baseline for crossovers

        for symbol in self.symbols:
            # Skip if data not available
            if not self._has_valid_data(symbol):
                continue

            # Check stop loss and take profit first
            if self.portfolio[symbol].invested:
                if self._check_stop_loss(symbol) or self._check_take_profit(symbol):
                    self.pending_exits.add(symbol)
                    continue

                # Check max holding period
                if self._check_max_holding(symbol):
                    self.pending_exits.add(symbol)
                    continue

            # Generate signals
            if self.portfolio[symbol].invested:
                # Check exit conditions
                if self._check_exit_conditions(symbol):
                    self.pending_exits.add(symbol)
            else:
                # Check entry conditions
                if self._check_entry_conditions(symbol):
                    self.pending_entries.add(symbol)

        # Update previous indicator values for crossover detection
        self._update_prev_values()

    def _passes_filters(self, symbol) -> bool:
        """
        SAFETY: Liquidity and price filters.
        """
        security = self.securities[symbol]

        # Price filter: min $5
        if security.price < 5.0:
            return False

        # Volume filter: check if we have volume data
        history = self.history(symbol, 5, Resolution.DAILY)
        if history.empty:
            return False

        # Calculate average dollar volume
        avg_volume = history['volume'].mean()
        avg_price = history['close'].mean()
        avg_dollar_volume = avg_volume * avg_price

        if avg_dollar_volume < 500000:
            return False

        return True

    def _has_valid_data(self, symbol) -> bool:
        """Check if we have valid data for the symbol"""
        if symbol not in self.securities:
            return False
        security = self.securities[symbol]
        if security.price <= 0:
            return False
        # Check indicators are ready
        for ind_name, ind in self.indicators.get(symbol, {}).items():
            if not ind.is_ready:
                return False
        return True

    def _check_stop_loss(self, symbol) -> bool:
        """Check if stop loss is triggered"""
        if self.stop_loss_pct is None:
            return False
        if symbol not in self.entry_prices:
            return False
        entry_price = self.entry_prices[symbol]
        current_price = self.securities[symbol].price
        loss_pct = (entry_price - current_price) / entry_price
        return loss_pct >= self.stop_loss_pct

    def _check_take_profit(self, symbol) -> bool:
        """Check if take profit is triggered"""
        if self.take_profit_pct is None:
            return False
        if symbol not in self.entry_prices:
            return False
        entry_price = self.entry_prices[symbol]
        current_price = self.securities[symbol].price
        gain_pct = (current_price - entry_price) / entry_price
        return gain_pct >= self.take_profit_pct

    def _check_max_holding(self, symbol) -> bool:
        """Check if max holding period is exceeded"""
        if self.max_holding_days is None:
            return False
        if symbol not in self.entry_dates:
            return False
        holding_days = (self.time - self.entry_dates[symbol]).days
        return holding_days >= self.max_holding_days

    def _check_entry_conditions(self, symbol) -> bool:
        """
        Check if entry conditions are met.
        GENERATED CODE - DO NOT EDIT
        """
        return (self._crosses_above(symbol, "price", "sma_50"))

    def _check_exit_conditions(self, symbol) -> bool:
        """
        Check if exit conditions are met.
        GENERATED CODE - DO NOT EDIT
        """
        return (self._crosses_below(symbol, "price", "sma_50"))

    def _update_prev_values(self):
        """Store previous indicator values for crossover detection"""
        for symbol in self.symbols:
            if symbol not in self.prev_indicator_values:
                self.prev_indicator_values[symbol] = {}
            for ind_name, ind in self.indicators.get(symbol, {}).items():
                if ind.is_ready:
                    self.prev_indicator_values[symbol][ind_name] = float(ind.current.value)
            # Also store price
            if symbol in self.securities:
                self.prev_indicator_values[symbol]["price"] = float(self.securities[symbol].price)

    def _get_indicator_value(self, symbol, name) -> float:
        """Get current indicator value"""
        if name == "price" or name == "price.close":
            return float(self.securities[symbol].price)
        if name == "price.open":
            return float(self.securities[symbol].open)
        if name == "price.high":
            return float(self.securities[symbol].high)
        if name == "price.low":
            return float(self.securities[symbol].low)
        if name == "volume":
            return float(self.securities[symbol].volume)

        indicators = self.indicators.get(symbol, {})
        if name in indicators:
            return float(indicators[name].current.value)
        return 0.0

    def _get_prev_value(self, symbol, name):
        """Get previous indicator value for crossover detection. Returns None if not available."""
        prev = self.prev_indicator_values.get(symbol, {})
        return prev.get(name)  # Returns None if not present

    def _crosses_above(self, symbol, left_name, right_name) -> bool:
        """Check if left crossed above right"""
        left_curr = self._get_indicator_value(symbol, left_name)
        left_prev = self._get_prev_value(symbol, left_name)

        # Can't detect crossover without previous values
        if left_prev is None:
            return False

        if isinstance(right_name, (int, float)):
            right_curr = float(right_name)
            right_prev = float(right_name)
        else:
            right_curr = self._get_indicator_value(symbol, right_name)
            right_prev = self._get_prev_value(symbol, right_name)
            if right_prev is None:
                return False

        return left_prev <= right_prev and left_curr > right_curr

    def _crosses_below(self, symbol, left_name, right_name) -> bool:
        """Check if left crossed below right"""
        left_curr = self._get_indicator_value(symbol, left_name)
        left_prev = self._get_prev_value(symbol, left_name)

        # Can't detect crossover without previous values
        if left_prev is None:
            return False

        if isinstance(right_name, (int, float)):
            right_curr = float(right_name)
            right_prev = float(right_name)
        else:
            right_curr = self._get_indicator_value(symbol, right_name)
            right_prev = self._get_prev_value(symbol, right_name)
            if right_prev is None:
                return False

        return left_prev >= right_prev and left_curr < right_curr

    def on_data(self, data):
        """
        Required method - but we use scheduled events for trading.
        This ensures consistent timing regardless of data arrival.
        """
        pass
